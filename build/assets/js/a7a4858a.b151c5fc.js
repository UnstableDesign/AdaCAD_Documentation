"use strict";(self.webpackChunkada_cad_docs=self.webpackChunkada_cad_docs||[]).push([[7930],{29299:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>d});var a=t(85893),r=t(11151);const o={sidebar_position:1},s="How to Make an Operation",i={id:"develop/makeanoperation",title:"How to Make an Operation",description:"To make an operation, you need to make create or make changes to four files:",source:"@site/docs/develop/makeanoperation.md",sourceDirName:"develop",slug:"/develop/makeanoperation",permalink:"/docs/develop/makeanoperation",draft:!1,unlisted:!1,editUrl:"https://github.com/UnstableDesign/AdaCAD_Documentation/tree/main/docs/develop/makeanoperation.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"devSidebar",previous:{title:"Install AdaCAD",permalink:"/docs/develop/install"},next:{title:"Cell",permalink:"/docs/develop/reference/cell/"}},l={},d=[{value:"1. Create the Operation File",id:"1-create-the-operation-file",level:2},{value:"Understanding this File",id:"understanding-this-file",level:3},{value:"2. Register the Operation with the Operation Service",id:"2-register-the-operation-with-the-operation-service",level:2},{value:"3. Write an Operation Description",id:"3-write-an-operation-description",level:2},{value:"4. Classify Your Operation",id:"4-classify-your-operation",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"how-to-make-an-operation",children:"How to Make an Operation"}),"\n",(0,a.jsx)(n.h1,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"To make an operation, you need to make create or make changes to four files:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Type"}),(0,a.jsx)(n.th,{children:"Path"}),(0,a.jsx)(n.th,{children:"Status"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"An operation"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"src/app/core/operations/<operation-name>/<operation-name.ts> "})}),(0,a.jsx)(n.td,{children:"Create"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"An operation service"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"src/app/core/provider/operation.service.ts"})}),(0,a.jsx)(n.td,{children:"Update"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"An operation description"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"src/assets/json/op_descriptions.json"})}),(0,a.jsx)(n.td,{children:"Update"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"An operation classification"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"src/assets/json/op_classifications.json"})}),(0,a.jsx)(n.td,{children:"Update"})]})]})]}),"\n",(0,a.jsx)(n.h1,{id:"tutorial-creating-the-all-up-operation",children:'Tutorial: Creating the "All Up" Operation'}),"\n",(0,a.jsxs)(n.p,{children:["This is a walkthrough of the simplest operation: an ",(0,a.jsx)(n.code,{children:"all up"})," operation that lifts all warps. It starts with the minimum elements to make a component. Note the customized areas that create the behavior for ",(0,a.jsx)(n.code,{children:"all up"})," ."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"All Up Operation",src:t(73752).Z+"",width:"400",height:"538"})}),"\n",(0,a.jsx)(n.h2,{id:"1-create-the-operation-file",children:"1. Create the Operation File"}),"\n",(0,a.jsxs)(n.p,{children:["To start, we navigate to  the ",(0,a.jsx)(n.code,{children:"operations"})," folder, and create this file, named file ",(0,a.jsx)(n.code,{children:"allup.ts"}),", within a folder called ",(0,a.jsx)(n.code,{children:"allup"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'import { NumParam, OpParamVal, OpInput, Operation } from "../../model/datatypes";\nimport { getOpParamValById } from "../../model/operations";\nimport { Sequence } from "../../model/sequence";\nimport { initDraftFromDrawdown } from "../../model/drafts";\n\n\nconst name = "all_up";\nconst old_names = [];\n\n//PARAMS\nconst warps:NumParam =  \n    {name: \'num warps\',\n    type: \'number\',\n    min: 1,\n    max: 10,\n    value: 1,\n    dx: "all warps lifted"\n};\n\nconst params = [warps];\n\nconst inlets = [];\n\nconst perform = (param_vals: Array<OpParamVal>, op_inputs: Array<OpInput>) => {\n    const num_up: number = getOpParamValById(0, param_vals);\n\n    let first_row = new Sequence.OneD();\n    first_row.pushMultiple(1, num_up);\n\n    let pattern = new Sequence.TwoD();\n    pattern.pushWeftSequence(first_row.val());\n\n    return Promise.resolve([initDraftFromDrawdown(pattern.export())]);\n}\n\nconst generateName = (param_vals: Array<OpParamVal>, op_inputs: Array<OpInput>) : string => {\n    const num_up: number = getOpParamValById(0, param_vals);\n    return num_up + \'/all-up\';\n}\n\nexport const all_up: Operation = {name, old_names, params, inlets, perform, generateName};\n'})}),"\n",(0,a.jsx)(n.h3,{id:"understanding-this-file",children:"Understanding this File"}),"\n",(0,a.jsx)(n.p,{children:"The imports to this file bring in custom defined types and helpers that allow us to define our operation and manipulate the cells in a draft."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'import { NumParam, OpParamVal, OpInput, Operation } from "../../model/datatypes";\nimport { getOpParamValById } from "../../model/operations";\nimport { Sequence } from "../../model/sequence";\nimport { initDraftFromDrawdown } from "../../model/drafts";\n'})}),"\n",(0,a.jsx)(n.p,{children:"Next, we assign this an internal name. This won't be the name shown to the user, just a unique name that we can use to refer to this operation within the code. The old names field is only used if there is an existing operation that you would like to replace with this operation."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'const name = "all_up";\nconst old_names = [];\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Now we get to define the ",(0,a.jsx)(n.a,{href:"../reference/glossary/parameter",children:"parameters"})," that this operation will use to generate or modify a draft. These fields are used to create user-inputs on screen and can take on several types outlined in the ",(0,a.jsx)(n.a,{href:"/docs/reference/glossary/operation",children:"operation"})," reference section. Here we are going to have our ",(0,a.jsx)(n.code,{children:"all up"})," operation take on input parameter, a number, that is used to describe the number of warps in the structure."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"//PARAMS\nconst warps:NumParam =  \n    {name: 'num warps',   //this name that will be visible to the user\n    type: 'number',       //this describes the kind of parameter \n    min: 1,               //the minimum value for this parameter\n    max: 10,              //the maximum value for this parameter\n    value: 1,             //the default value \n    dx: \"all warps lifted\" // a description of this parameter to be used on the auto-generated \"help\" page\n};\n\nconst params = [warps]; //push all the parameters to an array called params.\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"Next, we describe the kind and number of inputs that a user can add to this operation. Since this operation will not take any inputs, we initialize a blank array."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"const inlets = [];\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now the most important part: the code that runs anytime someone adds, changes or performs this operation. This function will be called anytime AdaCAD detects the need for the drafts to recompute."}),"\n",(0,a.jsxs)(n.p,{children:["To ensure interoperability, this function must take and produce inputs and outputs the same time. Specifically, the perform operation is called with an array of ",(0,a.jsx)(n.code,{children:"OpParamVal"})," objects. This array contains data about the parameters and values currently set on the operation. It also takes in an array of ",(0,a.jsx)(n.code,{children:"OpInputs"})," objects. These hold every draft that has been connected to an inlet/input to the operation."]}),"\n",(0,a.jsxs)(n.p,{children:["The perform function also returns a ",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",children:(0,a.jsx)(n.code,{children:"Promise"})})," for an Array of Drafts. We use javascript's ",(0,a.jsx)(n.code,{children:"Promise"})," because it allows us to ensure that one function completes before the next operation is performed. For this reason, you don't just return an array of drafts that you want this operation to create, but a ",(0,a.jsx)(n.code,{children:"Promise.resolve()"})," that contains the array of drafts that you created."]}),"\n",(0,a.jsxs)(n.p,{children:["Internally, this perform function uses the helper class ",(0,a.jsx)(n.a,{href:"/docs/develop/reference/sequence/",children:"Sequence"})," to generate and manipulate values that will be turned into a draft. You can think of a OneD sequence as a row in a draft, with 1 representing a lifted heddle and 0, a lowered heddle. A TwoD sequence is a collection of rows (e.g. multiple picks in a draft). The benefit of using Sequence, rather than a 2D array of numbers, is that the Sequence class supports sequential manipulations and also supports conversion from number sequence to AdaCAD's draft and cell objects."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"const perform = (param_vals: Array<OpParamVal>, op_inputs: Array<OpInput>) => {\n\n    const num_up: number = getOpParamValById(0, param_vals);\n\n    let first_row = new Sequence.OneD();\n    first_row.pushMultiple(1, num_up); //in num_up = 3, this pushes [1, 1, 1] to the sequence\n\n    let pattern = new Sequence.TwoD();\n    pattern.pushWeftSequence(first_row.val());  \n\n    return Promise.resolve([initDraftFromDrawdown(pattern.export())]); R\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:'Each operation also has to have a "generateName" function that creates a name to be assigned to the draft created by this operation.'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"const generateName = (param_vals: Array<OpParamVal>, op_inputs: Array<OpInput>) : string => {\n    const num_up: number = getOpParamValById(0, param_vals);\n    return num_up + '/all-up';\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Lastly, and most important, you package all the functions and variables you defined above into an ",(0,a.jsx)(n.a,{href:"/docs/develop/reference/operation/",children:(0,a.jsx)(n.code,{children:"Operation"})})," object."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"export const all_up: Operation = {name, old_names, params, inlets, perform, generateName};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"2-register-the-operation-with-the-operation-service",children:"2. Register the Operation with the Operation Service"}),"\n",(0,a.jsx)(n.p,{children:"Once the operation is complete, add it to the operation service. This angular service keeps a record of all the Operation objects available for use within AdaCAD. Essentially, AdaCAD won't know that you've created the all up operation unless you've added it here."}),"\n",(0,a.jsxs)(n.p,{children:["First, import the ",(0,a.jsx)(n.code,{children:"all_up"})," operation that was just created."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"import { all_up } from '../operations/all_up/all_up';\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Next, push the Operation created in the ",(0,a.jsx)(n.code,{children:"all_up"})," file to a list of operations stored called ",(0,a.jsx)(n.code,{children:"ops"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"this.ops.push(all_up);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"3-write-an-operation-description",children:"3. Write an Operation Description"}),"\n",(0,a.jsxs)(n.p,{children:["Then, add an operation description that defines the operation and its application. The operation will not show up on the AdaCAD interface without a description in  ",(0,a.jsx)(n.code,{children:"src/assets/json/op_descriptions.json"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'{\n   "name":"all_up",                           //make sure this is the same as the "name" field in your operation\n   "tags": ["advanced"],                      // if the advanced tag is added it will only show up if users has selected to show advanced operations\n   "displayname": "all up",                   //this is the name that will show to users on the interface\n   "description": "All warps lifted.",        // a description of what this operation does\n   "description": "All warps lifted.",        // a description of what this operation does\n   "application": "Generates all warps lifted." //an example application for this operation\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"4-classify-your-operation",children:"4. Classify Your Operation"}),"\n",(0,a.jsx)(n.p,{children:"All operations in AdaCAD belong to a category and these categories and associated operations are listed on the interface. Adding the operation to a classification like structure is the last place in AdaCAD to include all_up. You can add your operation to an existing category or add a new category of your own:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'\n{\n    "category_name": "structure",\n    "description": "A weave structure is the order or pattern of interlacement between the warp and weft threads. There are different families of woven structure that share core properties, such as plain weave, twill, and satin. Each of the operations is capable of generating structures that obey the rules of a given family",\n    "op_names":[\n        ...\n        "all_up"\n     ]\n}\n\n'})})]})}function c(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},73752:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/makeop_allup-69714efe6286972eb5ab0f973d28192f.png"},11151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>s});var a=t(67294);const r={},o=a.createContext(r);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);