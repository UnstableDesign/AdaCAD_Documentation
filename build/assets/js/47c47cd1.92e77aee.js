"use strict";(self.webpackChunkada_cad_docs=self.webpackChunkada_cad_docs||[]).push([[2943],{57084:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var n=a(85893),s=a(11151);const i={title:"cut, (a, b) => (a NAND b)",sidebar_label:"cut, (a, b) => (a NAND b)",tags:["advanced","compute"]},o="cut, (a, b) => (a NAND b)",r={id:"reference/operations/cutout",title:"cut, (a, b) => (a NAND b)",description:"Applies binary math to two drafts. To do so, it looks at each interlacement in input drafts a and b. If a and b are both marked as having warped raised, it changes the value to warp lowered, effectively cutting the black cells in b from a. This is the opposite of mask",source:"@site/docs/reference/operations/cutout.md",sourceDirName:"reference/operations",slug:"/reference/operations/cutout",permalink:"/docs/reference/operations/cutout",draft:!1,unlisted:!1,editUrl:"https://github.com/UnstableDesign/AdaCAD_Documentation/tree/main/docs/reference/operations/cutout.md",tags:[{label:"advanced",permalink:"/docs/tags/advanced"},{label:"compute",permalink:"/docs/tags/compute"}],version:"current",frontMatter:{title:"cut, (a, b) => (a NAND b)",sidebar_label:"cut, (a, b) => (a NAND b)",tags:["advanced","compute"]},sidebar:"learnSidebar",previous:{title:"analyze system",permalink:"/docs/reference/operations/analyzesystem"},next:{title:"diff, (a, b) => (a NEQ b)",permalink:"/docs/reference/operations/diff"}},c={},d=[{value:"Parameters",id:"parameters",level:2},{value:"Application",id:"application",level:2},{value:"Developer",id:"developer",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"cut-a-b--a-nand-b",children:"cut, (a, b) => (a NAND b)"}),"\n",(0,n.jsx)(t.p,{children:"Applies binary math to two drafts. To do so, it looks at each interlacement in input drafts a and b. If a and b are both marked as having warped raised, it changes the value to warp lowered, effectively cutting the black cells in b from a. This is the opposite of mask"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"file",src:a(89333).Z+"",width:"1576",height:"1348"})}),"\n",(0,n.jsx)(t.h2,{id:"parameters",children:"Parameters"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"shift ends"}),": shifts the position of the ends in draft a"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"shift pics"}),": shifts the position of the pics in draft a"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"calculate repeats"}),": this defines what happens if/when you connect drafts with different pic numbers. If ",(0,n.jsx)(t.code,{children:"repeat inputs to match size"})," is selected, AdaCAD will expand the number of pics and ends in the output draft such that all structures repeat at the even intervals across along width and length of the cloth. If the ",(0,n.jsx)(t.code,{children:"do not repeat inputs to match size"})," is selected, unset rows will be added to drafts with fewer pics."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"application",children:"Application"}),"\n",(0,n.jsx)(t.p,{children:"No established application, but a fun way to see how to apply binary math to the production of drafts."}),"\n",(0,n.jsx)(t.h2,{id:"developer",children:"Developer"}),"\n",(0,n.jsxs)(t.p,{children:["adacad id: ",(0,n.jsx)(t.code,{children:"cutout"})]})]})}function p(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},89333:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/cutout-9390ecde0f06ed6632a642d658431170.png"},11151:(e,t,a)=>{a.d(t,{Z:()=>r,a:()=>o});var n=a(67294);const s={},i=n.createContext(s);function o(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);