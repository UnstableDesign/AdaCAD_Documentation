"use strict";(self.webpackChunkada_cad_docs=self.webpackChunkada_cad_docs||[]).push([[9036],{85661:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var n=t(85893),r=t(11151);const s={title:"mask, (a,b) => (a AND b)",sidebar_label:"mask, (a,b) => (a AND b)",tags:["advanced","compute"]},i="mask, (a,b) => (a AND b)",o={id:"reference/operations/mask",title:"mask, (a,b) => (a AND b)",description:"Applies binary math to two drafts. To do so, it looks at each interlacement in input drafts a and b  If a is marked warp raised and b marked warp raised, it sets the corresponding interlacement in the output draft to warp raised. Otherwise, the interlacement is marked warp lowered. This effectively masks draft a with draft b",source:"@site/docs/reference/operations/mask.md",sourceDirName:"reference/operations",slug:"/reference/operations/mask",permalink:"/docs/reference/operations/mask",draft:!1,unlisted:!1,editUrl:"https://github.com/UnstableDesign/AdaCAD_Documentation/tree/main/docs/reference/operations/mask.md",tags:[{label:"advanced",permalink:"/docs/tags/advanced"},{label:"compute",permalink:"/docs/tags/compute"}],version:"current",frontMatter:{title:"mask, (a,b) => (a AND b)",sidebar_label:"mask, (a,b) => (a AND b)",tags:["advanced","compute"]},sidebar:"learnSidebar",previous:{title:"diff, (a, b) => (a NEQ b)",permalink:"/docs/reference/operations/diff"},next:{title:"overlay, (a,b) => (a OR b)",permalink:"/docs/reference/operations/overlay"}},d={},c=[{value:"Parameters",id:"parameters",level:2},{value:"Application",id:"application",level:2},{value:"Developer",id:"developer",level:2}];function l(e){const a={code:"code",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",ul:"ul",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.h1,{id:"mask-ab--a-and-b",children:"mask, (a,b) => (a AND b)"}),"\n",(0,n.jsx)(a.p,{children:"Applies binary math to two drafts. To do so, it looks at each interlacement in input drafts a and b  If a is marked warp raised and b marked warp raised, it sets the corresponding interlacement in the output draft to warp raised. Otherwise, the interlacement is marked warp lowered. This effectively masks draft a with draft b"}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{alt:"file",src:t(71685).Z+"",width:"982",height:"1278"})}),"\n",(0,n.jsx)(a.h2,{id:"parameters",children:"Parameters"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.code,{children:"shift ends"}),": shifts the position of the ends in draft b relative to a"]}),"\n",(0,n.jsxs)(a.li,{children:[(0,n.jsx)(a.code,{children:"shift pics"}),": shifts the position of the pics in draft b relative to b"]}),"\n"]}),"\n",(0,n.jsx)(a.h2,{id:"application",children:"Application"}),"\n",(0,n.jsx)(a.p,{children:"No established application, but a fun way to see how to apply binary math to the production of drafts. Retains input draft b in regions where input draft a has raised warp ends (black cells); draft b is only retained within the area of draft a."}),"\n",(0,n.jsx)(a.h2,{id:"developer",children:"Developer"}),"\n",(0,n.jsxs)(a.p,{children:["adacad id: ",(0,n.jsx)(a.code,{children:"mask"})]})]})}function p(e={}){const{wrapper:a}={...(0,r.a)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},71685:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/mask-17505fa26120811e5f5b68207bf73549.png"},11151:(e,a,t)=>{t.d(a,{Z:()=>o,a:()=>i});var n=t(67294);const r={},s=n.createContext(r);function i(e){const a=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(s.Provider,{value:a},e.children)}}}]);